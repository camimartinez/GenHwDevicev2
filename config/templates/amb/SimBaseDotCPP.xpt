«REM»
ALMA - Atacama Large Millimiter Array
(c) European Southern Observatory, 2017
Copyright by ESO (in the framework of the ALMA collaboration),
All rights reserved

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
MA 02111-1307  USA
«ENDREM»

«IMPORT alma::control::datamodel::meta::base»
«IMPORT alma::control::datamodel::meta::amb»

«EXTENSION alma::control::templates::extensions::amb::util»

«DEFINE Root FOR DeviceModel»
  «IF !IsMonitorDBOnly()»
    «EXPAND SWModuleDef»
  «ENDIF»
«ENDDEFINE»

«DEFINE SWModuleDef FOR DeviceModel»
«FILE DirPath()+"/src/"+Assembly()+"SimBase.cpp"»
/**
 * ALMA - Atacama Large Millimiter Array
 * (c) European Southern Observatory, 2017
 * Copyright by ESO (in the framework of the ALMA collaboration),
 * All rights reserved
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
 * MA 02111-1307  USA
 *
 *             WARNING! DO NOT MODIFY THIS FILE!
 *  ---------------------------------------------------------
 * | This is generated code!  Do not modify this file.       |
 * | Any changes will be lost when the file is re-generated. |
 *  ---------------------------------------------------------
 *
 * Id: SimBaseDotCPP.xpt
 *
 */


#include <«Assembly()»SimBase.h>


«Assembly()»SimBase::«Assembly()»SimBase(const ACE_CString& name,
    maci::ContainerServices* cs):
    «Assembly()»Impl(name, cs),
    simulationModeEnabled(true)
{
    AUTO_TRACE(__PRETTY_FUNCTION__);

«FOREACH (Set[MonitorPoint]) monitorPoints.resources.contents AS x»
    «IF x.IsDependent() && x.Default() != "none"»
        «IF x.Default() == "mid"»
            «IF x.WorldDataToCPPType() != "double" && x.WorldDataToCPPType() != "float"»
    value«x.GetAltDependentName()» = static_cast< «x.WorldDataToCPPType()» >(
        («x.MinRange()» + «x.MaxRange()») / 2.0);
            «ELSE»
    value«x.GetAltDependentName()»= («x.MinRange()» + «x.MaxRange()») / 2.0;
            «ENDIF»
        «ELSE»
    value«x.GetAltDependentName()» = «x.Default()»;
        «ENDIF»
    «ENDIF»
«ENDFOREACH»
}

«Assembly()»SimBase::~«Assembly()»SimBase()
{
    AUTO_TRACE(__PRETTY_FUNCTION__);
}

«FOREACH (Set[MonitorPoint]) monitorPoints.resources.contents AS x»
    «EXPAND ProtectedMonitorPoint FOR x»
«ENDFOREACH»

«FOREACH (Set[ControlPoint]) controlPoints.resources.contents AS x»
    «EXPAND ProtectedControlPoint FOR x»
«ENDFOREACH»
«ENDFILE»
«ENDDEFINE»

«DEFINE ProtectedMonitorPoint FOR MonitorPoint»
/// MonitorPoint: «MPName()»
    «IF !IsExternal() || !IsMonitored()»
/// «DescriptionFormattedL5()»
    «ENDIF»
    «REM»
    a. Major monitor method
    «ENDREM»
    «IF IsImplemented()»
/// Get the current value of «MPName()» from the device.
        «IF !IsDependent()»
            «IF IsWorldDataArray()»
std::vector< «WorldDataToCPPType()» > «Assembly()»SimBase::get«AltMPName()»(
    ACS::Time& timestamp)
            «ELSE»
«WorldDataToCPPType()» «Assembly()»SimBase::get«AltMPName()»(
    ACS::Time& timestamp)
            «ENDIF»
{
    if((isReady() == false)
    || (inErrorState() == true))
    {
        ControlExceptions::INACTErrorExImpl ex(__FILE__, __LINE__,
            __PRETTY_FUNCTION__);
        std::ostringstream msg;
        msg << "Cannot execute monitor request.  Device is either inactive or "
            "in error state: "
            << getErrorMessage();
        ex.addData("Detail", msg.str());
        ex.log();
        throw ex;
    }
    else if(getHwState() != Control::HardwareDevice::Simulation)
    {
        return «Assembly()»Base::get«AltMPName()»(timestamp);
    }

            «IF IsWorldDataArray()»
    return std::vector< «WorldDataToCPPType()» >(«NumberItemsRawData()»);
            «ELSE»
    return 0;
            «ENDIF»
}
        «ENDIF»
    «ENDIF»
«ENDDEFINE»

«DEFINE ProtectedControlPoint FOR ControlPoint»
    «IF !IsDependent()»
        «IF Implement()»
«cppReturns()» «Assembly()»SimBase::set«AltCPName()»«cppDeclaration()»
{
    if((isReady() == false)
    || (inErrorState() == true))
    {
        ControlExceptions::INACTErrorExImpl ex(__FILE__, __LINE__,
            __PRETTY_FUNCTION__);
        std::ostringstream msg;
        msg << "Cannot execute control request.  Device is either inactive or "
            "in error state: "
            << getErrorMessage();
        ex.addData("Detail", msg.str());
        ex.log();
        throw ex;
    }
}
        «ENDIF»

/// ControlPoint: «CPName()»
        «IF !IsExternal()»
/// «DescriptionFormattedL5()»
        «ENDIF»
    «ENDIF»
«ENDDEFINE»