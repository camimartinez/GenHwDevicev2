«REM»
ALMA - Atacama Large Millimiter Array
(c) European Southern Observatory, 2017
Copyright by ESO (in the framework of the ALMA collaboration),
All rights reserved

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
MA 02111-1307  USA
«ENDREM»

«IMPORT alma::control::datamodel::meta::base»
«IMPORT alma::control::datamodel::meta::amb»

«EXTENSION alma::control::templates::extensions::amb::util»

«DEFINE Root FOR DeviceModel»
    «IF !IsMonitorDBOnly()»
        «EXPAND SWModuleDef»
    «ENDIF»
«ENDDEFINE»

«DEFINE SWModuleDef FOR DeviceModel»
«FILE DirPath()+"/include/"+Assembly()+"HWSimBase.h"»
#ifndef __cplusplus
#error This is a C++ include file and cannot be used from plain C.
#endif
#ifndef «Assembly()»HWSimBase_h
#define «Assembly()»HWSimBase_h
//
// ALMA - Atacama Large Millimiter Array
// (c) European Southern Observatory, 2017
// Copyright by ESO (in the framework of the ALMA collaboration),
// All rights reserved
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
// MA 02111-1307  USA
//
//           WARNING! DO NOT MODIFY THIS FILE!
//  ---------------------------------------------------------
// | This is generated code!  Do not modify this file.       |
// | Any changes will be lost when the file is re-generated. |
//  ---------------------------------------------------------
//
// Id: HWSimBaseDotH.xpt
//



«IF Extends() == "none"»
#include <CommonHWSim.h>
«ELSE»
#include <«Extends()»HWSimImpl.h>
«ENDIF»
#include <vector>
// For AMB::node_t and CAN::byte_t
#include <CANTypes.h>


namespace AMB
{
    /// The «Assembly()»HWSimBase class is the base class for the
    /// «DeviceName()» hardware simulator.
    /// <ul>
    /// <li> Device:   «DeviceName()»
    /// <li> Assembly: «Assembly()»
    /// <li> Parent:   «Parent()»
    /// <li> Node:     «NodeAddress()»
    /// <li> Channel:  «Channel()»
    /// </ul>
    class «Assembly()»HWSimBase:
«IF Extends() == "none"»
        public CommonHWSim
«ELSE»
        public «Extends()»HWSimImpl
«ENDIF»
    {
        public:
        /// Constructor
        /// \param node Node ID of this device
        /// \param serialNumber S/N of this device
        «Assembly()»HWSimBase(AMB::node_t node,
            const std::vector< CAN::byte_t >& serialNumber);

        /// Destructor
        virtual ~«Assembly()»HWSimBase()
        {
        };

        /// Monitor and Control Points creation (state_m map entries)
        /// and value initialization
        /// \param node Node ID of this device
        /// \param serialNumber S/N of this device
        /// \exception CAN::Error
        virtual void initialize(AMB::node_t node,
            const std::vector< CAN::byte_t >& serialNumber);

        /// Monitor interface ('get' functions for monitor points)
        /// \param rca CAN node RCA
        /// \return std::vector of bytes containing monitor info. Each response
        /// is sized to what's specified in the ICD.
        /// \exception CAN::Error
        virtual std::vector< CAN::byte_t > monitor(AMB::rca_t rca) const;

        /// Control points getter ('get' functions for control points)
        /// \param rca CAN node RCA
        virtual std::vector< CAN::byte_t > controlGetter(AMB::rca_t rca) const;

        /// Control Interface ('set' functions for control points)
        /// \param rca CAN node RCA
        /// \param data CAN message data required by device
        /// \exception CAN::Error
        virtual void control(AMB::rca_t rca,
            const std::vector< CAN::byte_t >& data);

        /// Monitor points setter ('set' functions for monitor points)
        /// \param rca CAN node RCA
        /// \param data CAN message data required by device
        virtual void monitorSetter(AMB::rca_t rca,
            const std::vector< CAN::byte_t >& data);

        /// Specific Monitor point RCAs for «Assembly()»
«FOREACH (Set[MonitorPoint]) monitorPoints.contents AS x»
    «IF !x.IsDependent()»
        static const AMB::rca_t monitorPoint_«x.MPName()»;
    «ENDIF»
«ENDFOREACH»

        /// Specific Monitor points Map for «Assembly()»
        std::map< const AMB::rca_t, std::vector< CAN::byte_t > (
            AMB::«Assembly()»HWSimBase::*)() const > monitorPointsMap;

        /// Specific Control point RCAs for «Assembly()»
«FOREACH (Set[ControlPoint]) controlPoints.contents AS x»
    «IF !x.IsDependent()»
        static const AMB::rca_t controlPoint_«x.CPName()»;
    «ENDIF»
«ENDFOREACH»

        /// Specific Control points Map for «Assembly()»
        std::map< const AMB::rca_t, void (AMB::«Assembly()»HWSimBase::*)(
            const std::vector< CAN::byte_t >& data) > controlPointsMap;


        protected:
        /// Specific Monitor get helper functions
«FOREACH (Set[MonitorPoint]) monitorPoints.contents AS x»
    «IF !x.IsDependent()»
        virtual std::vector< CAN::byte_t > getMonitor«x.GetAltDependentName()»Proxy() const;

        virtual std::vector< CAN::byte_t > getMonitor«x.GetAltDependentName()»() const;
    «ENDIF»
«ENDFOREACH»

        /// Specific Control get helper functions
«FOREACH (Set[ControlPoint]) controlPoints.contents AS x»
    «IF !x.IsDependent()»
        virtual std::vector< CAN::byte_t > getControl«x.GetAltDependentName()»Proxy() const;

        virtual std::vector< CAN::byte_t > getControl«x.GetAltDependentName()»() const;
    «ENDIF»
«ENDFOREACH»

        /// Specific Control points get helper Map for «Assembly()»
        std::map< const AMB::rca_t, std::vector< CAN::byte_t > (
            AMB::«Assembly()»HWSimBase::*)() const > controlPointsGetterMap;

        /// Specific Control set helper functions
«FOREACH (Set[ControlPoint]) controlPoints.contents AS x»
    «IF !x.IsDependent()»
        /// \exception CAN:Error
        virtual void setControl«x.GetAltDependentName()»Proxy(
            const std::vector< CAN::byte_t >& data);

        /// \exception CAN:Error
        virtual void setControl«x.GetAltDependentName()»(
            const std::vector< CAN::byte_t >& data);
    «ENDIF»
«ENDFOREACH»

        /// Specific Monitor set helper functions
«FOREACH (Set[MonitorPoint]) monitorPoints.contents AS x»
    «IF !x.IsDependent()»
        /// \exception CAN:Error
        virtual void setMonitor«x.GetAltDependentName()»Proxy(
            const std::vector< CAN::byte_t >& data);

        /// \exception CAN:Error
        virtual void setMonitor«x.GetAltDependentName()»(
            const std::vector< CAN::byte_t >& data);
    «ENDIF»
«ENDFOREACH»

        /// Specific Monitor points set helper Map for «Assembly()»
        std::map< const AMB::rca_t, void (AMB::«Assembly()»HWSimBase::*)(
            const std::vector< CAN::byte_t >& data) > monitorPointsSetterMap;

        virtual void setBaseAddress(unsigned long arg);
        virtual unsigned long getBaseAddress() const;


        private:
        /// No default ctor.
        «Assembly()»HWSimBase();

        /// No copy ctor.
        «Assembly()»HWSimBase(const «Assembly()»HWSimBase&);

        /// No assigment optor.
        «Assembly()»HWSimBase& operator=(const «Assembly()»HWSimBase&);

        unsigned long baseAddress_m;
    };
}
#endif
«ENDFILE»
«ENDDEFINE»