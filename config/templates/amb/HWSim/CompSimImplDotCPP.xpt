«REM»
ALMA - Atacama Large Millimiter Array
(c) European Southern Observatory, 2017
Copyright by ESO (in the framework of the ALMA collaboration),
All rights reserved

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
MA 02111-1307  USA
«ENDREM»

«IMPORT org::eclipse::emf::common::notify::Notification»
«IMPORT org::eclipse::emf::ecore::EClass»
«IMPORT org::eclipse::emf::ecore::InternalEObject»
«IMPORT org::eclipse::emf::ecore::impl::ENotificationImpl»
«IMPORT alma::Control::datamodel::meta::base::impl»
«IMPORT alma::Control::datamodel::meta::amb::impl»

«DEFINE Root FOR DeviceModelImpl»
    «IF !IsMonitorDBOnly»
        «EXPAND SWModuleDef»
    «ENDIF»
«ENDDEFINE»

«DEFINE SWModuleDef FOR DeviceModelImpl»
«FILE DirPath+"/src/"+Assembly+"CompSimImpl.cpp"»
// ALMA - Atacama Large Millimiter Array
// (c) European Southern Observatory, 2017
// Copyright by ESO (in the framework of the ALMA collaboration),
// All rights reserved
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
// MA 02111-1307  USA
//
//           WARNING! DO NOT MODIFY THIS FILE!
//  ---------------------------------------------------------
// | This is generated code!  Do not modify this file.       |
// | Any changes will be lost when the file is re-generated. |
//  ---------------------------------------------------------
//

#include <«Assembly»CompSimImpl.h>
#include <«Assembly»HWSimImpl.h>
#include <string>
#include <sstream>
// For audience logs.
#include <LogToAudience.h>
#include <maciContainerServices.h>
#include <TypeConversion.h>
#include <Utils.h>
#include <SimulatedSerialNumber.h>
«IF Parent != "root"»
#include <boost/lexical_cast.hpp>
«ENDIF


// Please use this class to implement alternative component, extending
// the «Assembly»CompSimBase class.


«Assembly»CompSimImpl::«Assembly»CompSimImpl(const ACE_CString& name,
    maci::ContainerServices* cs):
    «Assembly»CompSimBase(name, cs)
{
    AUTO_TRACE(__PRETTY_FUNCTION__);

    const std::string componentName(name.c_str());
    «IF Parent != "root"»
    const std::string subComponentName(
        componentName.substr(0, componentName.find_last_of('/')));
    const unsigned long long hashed_sn(AMB::Utils::getSimSerialNumber(
        subComponentName, boost::lexical_cast< std::string >(8)));
    «ELSE»
    const unsigned long long hashed_sn(AMB::Utils::getSimSerialNumber(
        componentName, "«Assembly»"));
    «ENDIF
    std::ostringstream msg;
    msg << "simSerialNumber for \""
        << componentName
        << "\" with assembly name \"«Assembly»\" is 0x"
        << std::hex
        << hashed_sn;
    LOG_TO_DEVELOPER(LM_DEBUG, msg.str());
    
    std::vector< CAN::byte_t > sn;
    AMB::TypeConversion::valueToData(sn, hashed_sn, 8U);

    «IF (NodeAddress != "none") && (NodeAddress != "parm")»
    const AMB::node_t node(«NodeAddress»U);
    «ELSE»
    const AMB::node_t node(0U);
    «ENDIF

    simulationObject.reset(new AMB::«Assembly»HWSimImpl(node, sn));
    simulationIf_m.setSimObj(simulationObject.get());
}

#include <maciACSComponentDefines.h>
MACI_DLL_SUPPORT_FUNCTIONS(«Assembly»CompSimImpl)
«ENDFILE»
«ENDDEFINE»